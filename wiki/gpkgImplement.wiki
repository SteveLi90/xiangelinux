#labels Featured
#用户接口gpkg的实现方案

= 0.简介 =

本文介绍了弦歌Linux包管理系统gpkg的实现方案。关于gpkg的功能说明，请参考文档[xgpkg]


= 1.下载软件包=

下载软件包通过gpkg -d 命令, 例如 gpkg -d autoconf. <br>
首先，gpkg需要知道autoconf软件包的下载地址(URL), 和校验码/大小信息。这些信息每个软件包都不同，所以每个软件包都需要一个脚本文件，描述软件包相关的信息。假如autoconf对应的脚本文件为autoconf.xgb (xiange build file), 下载的流程如下

1.1 得到软件包对应的脚本文件autoconf-2.61.xgb,失败则返回1<br>
    * 可以通过函数find_pack()实现
    * find_pack() 先用ls列出所有包类型目录中的子目录，放入变量pack_type里
    * 对pack_type里的个子目录, 用ls列出属于这个类别的所有包，进行匹配操作，如果成功，将结果放入result变量里，如app-sys/autoconf, app-test/autoconf-test
    * 继续操作直到所有目录匹配完成
    * 对每个result里的结果，找到最新的包编译脚本文件，如app-sys/autoconf/autoconf-2.63.xgb
    * 如果搜索到多个结果，让用户选择下载哪个
1.2 调用包编译脚本文件的下载接口函数<br>
    * 将步骤1.1得到的xgb文件包含进来，如“. path/app-sys/autoconf/autoconf-2.63.xgb”
    * 调用接口函数gpkg_getsrc()
1.3 脚本实现gpkg_getsrc()时，需要先在本地(/var/xiange/sources/)检查文件是否已下载，是的话转1.5<br>
1.4 下载文件到本地(/var/xiange/sources/)，失败后重试。重试次数超过5,失败返回2<br>
1.5 校验MD5Sum和文件大小，失败后重新下载，重试次数超过5， 返回3<br>
1.6 重复直至所有文件下载完毕，返回0表示成功。<br>

= 2. 软件包脚本文件=

从上面可以看到，每个软件包需要自己的编译脚本，提供以下函数(功能):

===2.1  gpkg_getsrc()===
    gpkg需要下载源码和补丁时,调用这个功能。源码需要下载到/var/xiange/source/目录.<br>
    实现时可以调用下载函数download_and_check, 参数为 URL MD5Sum Size<br>
    如: download_and_check http://www.abc.com/autoconf-2.63.tar.bz2 01003FBC88901234 115260. 这个函数返回0 表示成功， 返回1表示下载失败，返回2表示尺寸校验失败， 返回3表示MD5校验失败。
    直接返回download_and_check的值即可。
    
===2.1  gpkg_getbin()===
    gpkg需要下载预编译好的包时,调用这个功能。实现时可以调用下载函数download_and_check.<br>
    返回0表示成功, 其他表示失败。<br>
    先留接口，以后再考虑实现。

===2.3 gpkg_dep===
    告诉gpkg软件包的依赖关系. 这是一个变量。
    如"gtk2 libxxx"<br>
    用空格隔开. 不依赖任何包包时为空字串"".

    复杂一点可以支持版本限定, 如<br>
    gtk(>2.12) libxxx(<3.0) foo(=2.1)  bar(>2.13<2.15)<br>

    再复杂一点支持条件编译<br>
    如 "gtk[X,-xxx](>2.12) libxxx[opt1,-opt2](=2.1)"



===2.3 gpkg_unpack()===
    gpkg在安装指定软件包前，先调用软件包对应脚本文件的unpack功能，将下载的源码解到/tmp/xiange/sources/包名称/, 并打上所有补丁, 必要时, 可以重新执行autoconf, automake, 生成新的configure文件<br>
    成功返回0, 否则1并显示错误信息. 

    可以调用公共bash函数die和errcheck.<br>
    * die $MESG*<br>
    显示$MESG后调用exit 1<br>

    * errcheck $MESG*<br>
    先检查当前的返回值$?, 如果不为0, 调用die $MESG



===2.4 gpkg_config()===
    gpkg调用脚本的unpack解压到/tmp/xiange/包名称/sources/后，进入这个目录，接着调用config功能对软件包进行配置. 配置由三个大部分组成, 一为安装目录, 即--prefix, --sysconfdir等, 这个每个软件包都一样, 用变量$XIANGEDIR表示
    $XIANGEDIR=--prefix=/usr --sysconfdir=/etc 还有其他的运行库目录了, 文档目录等.<br>

    第二部分为C/C++的优化参数, 用$XIANGE_CFLAGS表示, 如-o2等<br>

    第三步部分为软件包特有的, 可以直接写到脚本里, 或暴露给用户设置(待讨论).<br>

    成功返回0, 否则2并显示错误信息.<br>


===2.5 gpkg_build() ===
    gpkg调用脚本config成功后，调用build功能编译软件包.<br>
    成功返回0, 否则3并显示错误信息.<br>
 

===2.6 gpkg_install()===
    编译完成后，gpkg调用install将软件包安装到/tmp/xiange/包名称/pack/. 这个位置用$D表示。注意不能直接安装到根目录！<br>

    接着gpkg会枚举$D目录下所有文件，对每个文件使用记录工具xgfileinfo得到文件信息，包括文件名，文件类型，最后修改时间，权限，大小，MD5等信息，记录到数据库文件$D/var/xiange/db/包名称/file文件，然后将软件包信息，包括软件包名称, 配置参数, 安装时间, 占用磁盘大小等存入$D/var/xiange/db/包名称/info文件. 然后将软件包编辑脚本拷贝到$D/var/xiange/db/包名称/xgbuild. 最后，将$D目录的所有文件拷贝到根目录。<br>

    将$D目录下的文件打包，即可以做成Binary格式的发行包。


===2.7 gpkg_postinst()===
    gpkg将软件包拷贝到根目录后, 调用脚本的postinst , 执行一些特有的操作, 如创建用户, 修改启动脚本等.这些功能可以调用gpkg提供的接口函数完成。

===2.8 gpkg_checkupdate()===
    需要检查当前软件有没有最新版本时, 调用这个功能. <br>
    脚本下载软件所在的网页, 解析网页找到最新的版本, 显示出来。

    可以写一个模板文件, 想编译新软件包时, 拷贝模板文件并编译即可.

===2.9 gpkg和包编译脚本的接口===
    gpkg想调用以上功能时，需要将脚本包含进来，直接调用相关的函数即可。如果编译脚本名为autoconf-2.63.xgb,gpkg调用时需要: <br>
    . path/autoconf-2.63.xgb<br>
    gpkg_getsrc <br>
    # check return value. <br>

 

= 3. 脚本库=

    软件包脚本库和Gentoo的ebuild库类似, 根据功能类别分组, 放在/var/xiange/libs/目录, 每个类别有自己的目录, 如app-sys.<br>
    类别目录下为软件目录, 由软件名称决定, 如autoconf, automake等.
    软件目录里包含软件各个版本的安装脚本，如autoconf-2.61.xgp, autoconf-2.62.xgp等

= 4. 编译脚本可用的函数接口=

    一些经常使用的功能可用写成函数，供软件包编译脚本使用。

=== 4.1 download_and_check() ===
    ||功能||从指定的网址下载文件，放到/var/xiange/source目录, 并校验MD5Sum||
    ||参数||URL : 文件位置，如 http://www.abc.com/test.tar.bz2<br>MD5SUM: 文件的MD5校验码，0表示不校验。<br>Size: 文件大小，以Byte为单位。0表示不要校验文件大小。||
    ||返回值||0表示成功<br>1表示下载失败<br>2表示文件大小不同<br>3表示MD5校验码错误||
  