#labels Featured
#用户接口gpkg的实现方案

= 0.简介 =

本文介绍了弦歌Linux包管理系统gpkg的实现方案。关于gpkg的功能说明，请参考文档[xgpkg]


= 1.下载软件包=

下载软件包通过gpkg -d 命令, 例如 gpkg -d autoconf. <br>
首先，gpkg需要知道autoconf软件包的下载地址(URL), 和校验码/大小信息。这些信息每个软件包都不同，所以每个软件包都需要一个脚本文件，描述软件包相关的信息。假如autoconf对应的脚本文件为autoconf.xgp, 下载的流程如下

1.1 得到软件包对应的脚本文件autoconf.xgp,失败则返回1<br>
1.2 调用脚本文件获取待下载文件的URL/MD5Sum/Size信息<br>
1.3 在本地检查文件是否已下载，是的话转1.5<br>
1.4 下载文件到本地，失败后重试。重试次数超过5,失败返回2<br>
1.5 校验MD5Sum和文件大小，失败后重新下载，重试次数超过5， 返回3<br>
1.6 重复直至所有文件下载完毕，返回0表示成功。<br>

= 2. 软件包脚本文件=

软件编译脚本应该负责以下事情:

===2.1  download===
即下载软件和补丁,  并进行md5或sha校验. 下载的目的用$S表示(Source), 默认为/usr/umklib/sources目录
下载并校验成功后返回0. 否则返回1.
如果发现软件可以在$S中找到, 可以直接使用$S中的原始文件校验.<br>

简称并下载的功能可以封装到标注bash函数中:

*check_and_download $URL*
$URL为软件或补丁的下载地址, 如 http://www.xxx.org/foo-1.2.3.tar.bz2
或http://www.xxx.org/$ATOM.$T

失败后应该显示错误信息, 可以调用公共bash函数die和errcheck.<br>
*die $MESG*<br>
显示$MESG后调用exit 1<br>

*errcheck $MESG*<br>
先检查当前的返回值$?, 如果不为0, 调用die $MESG


===2.2 getdep===
得到依赖关系, 在标注输出里打印出其依赖的软件包.
如 echo "gtk2 libxxx"<br>
用空格隔开. 不依赖任何包包时返回空字符串.

复杂一点可以支持版本限定, 如<br>
gtk(>2.12) libxxx(<3.0) foo(=2.1)  bar(>2.13<2.15)

===2.3 unpack===
将软件包解开到当前目录, 并打上所有补丁, 必要时, 可以重新执行autoconf, automake, 生成心得configure.<br>
成功返回0, 否则1并显示错误信息. 

===2.4 config===
    对软件包进行配置. 配置由三个大部分组成, 一为安装目录, 即--prefix, --sysconfdir等, 这个每个软件包都一样, 用标注变量$UMKDIR表示
    $UMKDIR=--prefix=/usr --sysconfdir=/etc 还有其他的运行库目录了, 文档目录等.<br>

    第二部分为C/C++的优化参数, 用$UMK_CFLAGS表示<br>

    第三步部分为软件包特有的, 可以直接写到脚本里.<br>


===2.5 build ===
    编译软件包.<br>
    如果编译出错, 允许用户修改后重新执行build操作.

===2.6 install===
    将软件包装到指定的位置. 指定位置用$D表示, 一般为/var/tmp/umk_image/$ATOM

    umk工具会将$D目录的信息收录到已安装数据库, 包括软件包名称, 配置参数, 安装时间, 文件列表, 每个文件的类型(文件/目录/链接), 文件最后修改时间, MD5或SHA校验码, 和文件大小. 并将所有文件拷贝到Root目录.

===2.7 postinst===
    umk工具将软件包拷贝到Root目录后, 调用软件包的postinst , 执行一些特有的操作, 如创建用户, 调整缓存, 修改启动脚本等.

===2.8 checkupdate===
    需要检查当前软件有没有最新版本时, 调用这个接口. <br>
    脚本应该下载软件所在的网页, 解析网页找到最新的版本, 并和当前版本比较, 如果发现不一样, 可以显示出来.


    可以写一个模板文件, 想编译新软件包时, 拷贝模板文件并编译即可.
