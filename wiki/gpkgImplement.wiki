#labels Featured
#用户接口gpkg的实现方案

= 0.简介 =

本文介绍了弦歌Linux包管理系统gpkg的实现方案。关于gpkg的功能说明，请参考文档[xgpkg]


= 1.下载软件包=

下载软件包通过gpkg -d 命令, 例如 gpkg -d autoconf. <br>
首先，gpkg需要知道autoconf软件包的下载地址(URL), 和校验码/大小信息。这些信息每个软件包都不同，所以每个软件包都需要一个脚本文件，描述软件包相关的信息。假如autoconf对应的脚本文件为autoconf.xgp, 下载的流程如下

1.1 得到软件包对应的脚本文件autoconf.xgp,失败则返回1<br>
1.2 调用脚本文件获取待下载文件的URL/MD5Sum/Size信息<br>
1.3 在本地检查文件是否已下载，是的话转1.5<br>
1.4 下载文件到本地，失败后重试。重试次数超过5,失败返回2<br>
1.5 校验MD5Sum和文件大小，失败后重新下载，重试次数超过5， 返回3<br>
1.6 重复直至所有文件下载完毕，返回0表示成功。<br>

= 2. 软件包脚本文件=

软件编译脚本应该负责以下事情:

===2.1  geturl===
告诉gpkg要下载软件的URL/校验码/大小。 可以通过变量返回，具体方法需要再讨论。


===2.2 getdep===
告诉gpkg软件包的依赖关系. 可以通过变量返回，具体方法需要再讨论。
也可以通过向stdout打印字串返回，
如 echo "gtk2 libxxx"<br>
用空格隔开. 不依赖任何包包时返回空字符串.

复杂一点可以支持版本限定, 如<br>
gtk(>2.12) libxxx(<3.0) foo(=2.1)  bar(>2.13<2.15)

===2.3 unpack===
gpkg在安装指定软件包前，先调用软件包对应脚本文件的unpack功能，将下载的源码解到指定目录, 并打上所有补丁, 必要时, 可以重新执行autoconf, automake, 生成新的configure.<br>
成功返回0, 否则1并显示错误信息. 

可以调用公共bash函数die和errcheck.<br>
*die $MESG*<br>
显示$MESG后调用exit 1<br>

*errcheck $MESG*<br>
先检查当前的返回值$?, 如果不为0, 调用die $MESG



===2.4 config===
    gpkg调用脚本的unpack后，接着调用config功能对软件包进行配置. 配置由三个大部分组成, 一为安装目录, 即--prefix, --sysconfdir等, 这个每个软件包都一样, 用标注变量$XIANGEDIR表示
    $XIANGEDIR=--prefix=/usr --sysconfdir=/etc 还有其他的运行库目录了, 文档目录等.<br>

    第二部分为C/C++的优化参数, 用$XIANGE_CFLAGS表示, 如-o2等<br>

    第三步部分为软件包特有的, 可以直接写到脚本里, 或暴露给用户设置(待讨论).<br>

    成功返回0, 否则1并显示错误信息.<br>


===2.5 build ===
    gpkg调用build功能编译软件包.<br>
    成功返回0, 否则1并显示错误信息.<br>
 

===2.6 install===
    gpkg调用install将软件包安装到指定的位置. 指定位置用$D表示, 一般为/var/tmp/xiange/$ATOM

    接着gpkg会调用记录工具会将$D目录的信息收录到已安装数据库, 包括软件包名称, 配置参数, 安装时间, 文件列表, 每个文件的类型(文件/目录/链接), 文件最后修改时间, MD5或SHA校验码, 和文件大小. 并将所有文件拷贝到根目录.(fakeroot安装方式)

===2.7 postinst===
    gpkg将软件包拷贝到根目录后, 调用脚本的postinst , 执行一些特有的操作, 如创建用户, 修改启动脚本等.

===2.8 checkupdate===
    需要检查当前软件有没有最新版本时, 调用这个功能. <br>
    脚本下载软件所在的网页, 解析网页找到最新的版本, 显示出来。

    可以写一个模板文件, 想编译新软件包时, 拷贝模板文件并编译即可.